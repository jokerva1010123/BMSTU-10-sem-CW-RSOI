// Code generated by MockGen. DO NOT EDIT.
// Source: comment.go

// Package comments is a generated GoMock package.
package comments

// import (
// 	reflect "reflect"

// 	gomock "github.com/golang/mock/gomock"
// )

// // MockCommentsRepo is a mock of CommentsRepo interface.
// type MockCommentsRepo struct {
// 	ctrl     *gomock.Controller
// 	recorder *MockCommentsRepoMockRecorder
// }

// // MockCommentsRepoMockRecorder is the mock recorder for MockCommentsRepo.
// type MockCommentsRepoMockRecorder struct {
// 	mock *MockCommentsRepo
// }

// // NewMockCommentsRepo creates a new mock instance.
// func NewMockCommentsRepo(ctrl *gomock.Controller) *MockCommentsRepo {
// 	mock := &MockCommentsRepo{ctrl: ctrl}
// 	mock.recorder = &MockCommentsRepoMockRecorder{mock}
// 	return mock
// }

// // EXPECT returns an object that allows the caller to indicate expected use.
// func (m *MockCommentsRepo) EXPECT() *MockCommentsRepoMockRecorder {
// 	return m.recorder
// }

// // Add mocks base method.
// func (m *MockCommentsRepo) Add(comment *Comment) (string, error) {
// 	m.ctrl.T.Helper()
// 	ret := m.ctrl.Call(m, "Add", comment)
// 	ret0, _ := ret[0].(string)
// 	ret1, _ := ret[1].(error)
// 	return ret0, ret1
// }

// // Add indicates an expected call of Add.
// func (mr *MockCommentsRepoMockRecorder) Add(comment interface{}) *gomock.Call {
// 	mr.mock.ctrl.T.Helper()
// 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Add", reflect.TypeOf((*MockCommentsRepo)(nil).Add), comment)
// }

// // AttachTo mocks base method.
// func (m *MockCommentsRepo) AttachTo(commentID string, target Commentable) error {
// 	m.ctrl.T.Helper()
// 	ret := m.ctrl.Call(m, "AttachTo", commentID, target)
// 	ret0, _ := ret[0].(error)
// 	return ret0
// }

// // AttachTo indicates an expected call of AttachTo.
// func (mr *MockCommentsRepoMockRecorder) AttachTo(commentID, target interface{}) *gomock.Call {
// 	mr.mock.ctrl.T.Helper()
// 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AttachTo", reflect.TypeOf((*MockCommentsRepo)(nil).AttachTo), commentID, target)
// }

// // DeleteFromRepo mocks base method.
// func (m *MockCommentsRepo) DeleteFromRepo(commentID string) (bool, error) {
// 	m.ctrl.T.Helper()
// 	ret := m.ctrl.Call(m, "DeleteFromRepo", commentID)
// 	ret0, _ := ret[0].(bool)
// 	ret1, _ := ret[1].(error)
// 	return ret0, ret1
// }

// // DeleteFromRepo indicates an expected call of DeleteFromRepo.
// func (mr *MockCommentsRepoMockRecorder) DeleteFromRepo(commentID interface{}) *gomock.Call {
// 	mr.mock.ctrl.T.Helper()
// 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteFromRepo", reflect.TypeOf((*MockCommentsRepo)(nil).DeleteFromRepo), commentID)
// }

// // GetByID mocks base method.
// func (m *MockCommentsRepo) GetByID(commentID string) (*Comment, error) {
// 	m.ctrl.T.Helper()
// 	ret := m.ctrl.Call(m, "GetByID", commentID)
// 	ret0, _ := ret[0].(*Comment)
// 	ret1, _ := ret[1].(error)
// 	return ret0, ret1
// }

// // GetByID indicates an expected call of GetByID.
// func (mr *MockCommentsRepoMockRecorder) GetByID(commentID interface{}) *gomock.Call {
// 	mr.mock.ctrl.T.Helper()
// 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByID", reflect.TypeOf((*MockCommentsRepo)(nil).GetByID), commentID)
// }

// // RemoveFrom mocks base method.
// func (m *MockCommentsRepo) RemoveFrom(commentID string, target Commentable) error {
// 	m.ctrl.T.Helper()
// 	ret := m.ctrl.Call(m, "RemoveFrom", commentID, target)
// 	ret0, _ := ret[0].(error)
// 	return ret0
// }

// // RemoveFrom indicates an expected call of RemoveFrom.
// func (mr *MockCommentsRepoMockRecorder) RemoveFrom(commentID, target interface{}) *gomock.Call {
// 	mr.mock.ctrl.T.Helper()
// 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveFrom", reflect.TypeOf((*MockCommentsRepo)(nil).RemoveFrom), commentID, target)
// }

// // MockCommentable is a mock of Commentable interface.
// type MockCommentable struct {
// 	ctrl     *gomock.Controller
// 	recorder *MockCommentableMockRecorder
// }

// // MockCommentableMockRecorder is the mock recorder for MockCommentable.
// type MockCommentableMockRecorder struct {
// 	mock *MockCommentable
// }

// // NewMockCommentable creates a new mock instance.
// func NewMockCommentable(ctrl *gomock.Controller) *MockCommentable {
// 	mock := &MockCommentable{ctrl: ctrl}
// 	mock.recorder = &MockCommentableMockRecorder{mock}
// 	return mock
// }

// // EXPECT returns an object that allows the caller to indicate expected use.
// func (m *MockCommentable) EXPECT() *MockCommentableMockRecorder {
// 	return m.recorder
// }

// // Attach mocks base method.
// func (m *MockCommentable) Attach(comment *Comment) error {
// 	m.ctrl.T.Helper()
// 	ret := m.ctrl.Call(m, "Attach", comment)
// 	ret0, _ := ret[0].(error)
// 	return ret0
// }

// // Attach indicates an expected call of Attach.
// func (mr *MockCommentableMockRecorder) Attach(comment interface{}) *gomock.Call {
// 	mr.mock.ctrl.T.Helper()
// 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Attach", reflect.TypeOf((*MockCommentable)(nil).Attach), comment)
// }

// // Unpin mocks base method.
// func (m *MockCommentable) Unpin(commentID string) error {
// 	m.ctrl.T.Helper()
// 	ret := m.ctrl.Call(m, "Unpin", commentID)
// 	ret0, _ := ret[0].(error)
// 	return ret0
// }

// // Unpin indicates an expected call of Unpin.
// func (mr *MockCommentableMockRecorder) Unpin(commentID interface{}) *gomock.Call {
// 	mr.mock.ctrl.T.Helper()
// 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unpin", reflect.TypeOf((*MockCommentable)(nil).Unpin), commentID)
// }
